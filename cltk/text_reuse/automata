"""
Constructs Levenshtein automata

At first, both the NFA and DFA classes inherited from a common Automaton class.
I found that treating the two as separate entities, results in more comprehensive
documentation in the price of succinctness.

Simplification methods along with proper docs and tests will be added soon.
"""
__author__ = ['Eleftheria Chatziargyriou <ele.hatzy@gmail.com>']
__license__ = 'MIT License. See LICENSE.'

import itertools

def powerset(S):
    """
    Constructs the powerset of a list

    >>> powerset([1, 2, 3])
    {(1, 2), (1, 3), (1,), (2,), (3,), (1, 2, 3), (), (2, 3)}
    """

    return set([k for i in range(len(S) + 1) for k in list(itertools.combinations(S, i))])

class DFA:

    """
    Define Deterministic finite automaton

    Explanation:
        A DFA is a finite state machine (note that it is not
        Turing equivalent) represented by a 5-tuple (Q, Σ, δ, s, F)

        Q: Finite set of states (the nodes of the DFA)

        Σ: Finite set of input symbols (the alphabet of the automaton)

        δ: Transition function δ: QxS -> Q

        s: Start state, s ∈ Q

        f: Finite set of final states  F ⊆ Q
    """

    def __init__(self, Nq, S, s, F, delta = False):
        """
        :param Nq: int: Number of states Q: q0, q1, ... q_Nq, |Q| = Nq + 1
        :param S: str set: Set of symbols recognized by the automaton
        :param s: int: The index of the starting state q_s
        :param F: int set: Set of accepted states {q'0, ... q'|F|)
        :param delta: Nq*|S| int transition matrix (defaults to empty transition matrix)
        """

        self.Nq = Nq
        self.S = S

        if s > self.Nq:
            print("The specified value is invalid, s must be a member of Q (s≤Nq)")
            raise ValueError
        else:
            self.s = s

        if sum([f > self.Nq for f in F]) != 0:
            print("The specified value is invalid, F must be a subset of Q (∀f∈F, f≤Nq)")
            raise ValueError
        else:
            self.F = F

        if delta:
            self.transition = delta
        else:
            self.transition = [[set() for _ in range(len(self.S))] for _ in range(self.Nq + 1)]

    def add_final_state(self, f):

        """
        :param f: int , the state qi to be added to F, epsilon is
        conventionally defined as the last node (q_|S|)
        """
        if f > self.Nq:
            print("The specified value is invalid, f must be a member of Q (f≤Nq)")
            raise ValueError

        self.F.add(f)

    def add_transition(self, qi, u, qj):
        """
        :param qi:int: current state, qi ∈ Q
        :param u:str: transition character u ∈ S
        :param qj:int: target state, qj ∈ Q, δ(qi, u) = qj

        If δ(qi, u) is already defined, the method replaces the
        already existent transition to qj.
        """
        try:
            self.transition[qi][self.S.index(u)] = qj

        except Exception as e:
            raise e

    def transition_function(self, qi, u):
        """
        :param qi: int: current state, qi ∈ Q
        :param u:str: transition character u ∈ S
        :returns Q': int :  δ(qi, u) = q
        """

        return self.transition[qi][self.S.index(u)]

    def accepted(self, w):
        """
        :param w: str: word to be fed to the automaton A
        :return: bool: Check whether w ∈ L(A)
        """

        active_state = self.s

        for char in w:

            tr = self.transition_function(active_state, char)

            #Check whether transition is valid
            if tr:
                active_state = tr

            #If its not, terminate
            else:
                active_state = -1
                break

        return active_state in self.F

class NFA:
    """
    Define Nondeterministic finite automaton

    Explanation:

        An NFA is essentially a finite state machine represented by a
        tuple (Q, Σ, δ, s, F)

        Q: Finite set of states (the nodes of the NFA)

        Σ: Finite set of input symbols (the alphabet of the automaton)

        δ: Transition function δ: QxS -> P(Q)

        s: Start state, s ∈ Q

        f: Finite set of final states  F ⊆ Q

    Methods:

        add_final_state

            Params:
                f: final state


            Explanation:
                Adds f to F, f ∈ Q

        add_transition

            Params:
                qi:int: current state, qi ∈ Q
                u:str: transition character u ∈ S
                qj:int: target state, qj ∈ Q, δ(qi, u) = qj

            Explanation:
                Defines an additional state to the transition function,
                such as δ(qi, u) = qj

        The nondeterministic property of the automaton arises from the codomain
        of δ. Instead of a single state q', δ(q, u) maps to an element of the
        powerset of Q, P(Q). As a simple example consider the following valid NFA:

        ({q0, q1, q2}, {a,b}, δ, q0, {q2})

        δ      a         b

        q0 {q0, q1) |    {q1}
        ________________________
        q1 {q2}     |  {q1, q2}
        _________________________
        q2 {q1}     | {q0, q1, q3}

    """

    def __init__(self, Nq, S, s, F, delta = False, isEpsilon = True):
        """
        :param Nq: int: Number of states Q: q0, q1, ... q_Nq, |Q| = Nq + 1
        :param S: str set: Set of symbols recognized by the automaton
        :param s: int: The index of the starting state q_s
        :param F: int set: Set of accepted states {q'0, ... q'|F|)
        :param delta: Nq*|S| int transition matrix (defaults to empty transition matrix)
        :param isEpsilon: bool: Specify whether the instance is an NFA-ε
        """
        self.Nq = Nq
        self.S = S
        self.isEpsilon = isEpsilon
        self.any = object()
        self.epsilon = object()

        if s > self.Nq:
            print("The specified value is invalid, s must be a member of Q (s≤Nq)")
            raise ValueError
        else:
            self.s = s

        if sum([f > self.Nq for f in F]) != 0:
            print("The specified value is invalid, F must be a subset of Q (∀f∈F, f≤Nq)")
            raise ValueError
        else:
            self.F = F

        if delta:
            self.transition = delta
        else:
            self.transition = [[set() for _ in range(len(self.S) + self.isEpsilon)] for _ in range(self.Nq + 1)]

    def add_final_state(self, f):
        """
        :param f: int , the state qi to be added to F, epsilon is
        conventionally defined as the last node (q_|S|)
        """
        if f > self.Nq:
            print("The specified value is invalid, f must be a member of Q (f≤Nq)")
            raise ValueError
        self.F.add(f)

    def add_transition(self, qi, u, qj):
        """
        :param qi:int: current state, qi ∈ Q
        :param u:str: transition character u ∈ S
        :param qj:int: target state, qj ∈ Q, δ(qi, u) = qj
        """
        try:

            if self.isEpsilon and u == self.epsilon:
                self.transition[qi][-1].add(qj)

            else:
                self.transition[qi][self.S.index(u)].add(qj)

        except Exception as e:
            raise e

    def transition_function(self, qi, u):
        """
        :param qi: int: current state, qi ∈ Q
        :param u:str: transition character u ∈ S
        :returns Q': int set: {q ∈ Q | δ(qi, u) = q, u ∈ S}
        """
        if u == self.epsilon:
            return self.transition[qi][-1]
        return self.transition[qi][self.S.index(u)]


    def to_DFA(self):
        """
        Converts NFA to DFA.
        :return: equivalent DFA
        """

        states = sorted(powerset([i for i in range(self.Nq + 1)]), key = len)

        visited_states = [self.s]

        if self.isEpsilon:
            active_states = [self.s]

            while active_states:
                try:
                    tmp_state = self.transition_function(active_states.pop(0), self.epsilon)
                except TypeError:
                    #active_states empty
                    break

                for tmp in tmp_state:
                    if tmp not in visited_states:
                        active_states.append(tmp)
                        visited_states.append(tmp)

        #The starting state s' is defined as the tuple of the states of A reached by epsilon-moves
        starting_state = states.index(tuple(sorted(visited_states)))

        transitions = [[set() for _ in range(len(self.S))] for _ in range(len(states))]

        for i, q in enumerate(states):
            for j, s in enumerate(self.S):

                visited_states = sorted(itertools.chain(*[self.transition_function(k, s) for k in q]))

                if self.isEpsilon:
                    active_states = list(visited_states)

                    try:
                        tmp_state = self.transition_function(active_states.pop(0), self.epsilon)
                        for tmp in tmp_state:
                            if tmp not in visited_states:
                                active_states.append(tmp)
                                visited_states.append(tmp)
                    except:
                        pass
                visited_states = sorted(list(set(visited_states)))
                transitions[i][j] = states.index(tuple(visited_states)) if visited_states else 0


        final_states = set()

        for i, state in enumerate(states):
            if self.F.intersection(set(state)):
                final_states.add(i)

        return DFA(len(transitions) - 1, self.S, starting_state, final_states, delta = transitions)


def levenshtein_automata(word, depth):

    A = NFA((len(word) + 1)*(depth + 1), list(set(word)) + ['*'], 0, set([(i + 1)*(len(word) + 1) - 1 \
                                                                          for i in range(depth + 1)]), isEpsilon=True)
    for i in range(depth):
        for j in range(len(word)):
            #Correct character
            A.add_transition((len(word) + 1)*i + j, word[j], (len(word) + 1)*i + j + 1)
            #Insertion
            A.add_transition((len(word) + 1)*i + j, A.epsilon, (len(word) + 1)*(i + 1) + j + 1)
            #Substitution
            A.add_transition((len(word) + 1)*i + j, "*", (len(word) + 1)*(i + 1) + j + 1)
            #Deletion
            A.add_transition((len(word) + 1)*i + j, "*", (len(word) + 1)*(i + 1) + j)

    for j in range(len(word)):
        A.add_transition((len(word) + 1)*depth + j, word[j], (len(word) + 1) *depth + j + 1)
    return A
